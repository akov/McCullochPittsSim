Andrew Kovacs McCullochPittsSim DocumentationOverview	The goal of this project was to provide a library for simulating McCulloch-Pitts Neurons in Java and to provide support code and example code of its use. The support code includes implementations of basic logic functions as well as a class for encapsulating networks of neurons.  Example code includes cases of using neurons and neuron-based logic gates to perform simple computations. Code Organization and External Interface	Package: lib – The main simulation libraryClass: Neuron – Represents a McCulloch-Pitts Neuron. This class is constructed with a threshold parameter. When the number of active InputBooleans or Neurons equals or exceeds the threshold then the Neuron will have a true value, otherwise it will be false. When its value changes in either direction it will send an update request to any downstream observers.Class: BufferNeuron – Defines a Neuron that has a threshold of 1 and is expected to have a single input. Interface: BooleanWrapper – Defines an interface for classes that can be interpreted as a   single booleanClass: InputBoolean – Defines a BooleanWrapper can be an input to a Connection.Class: OutputBoolean – Defines a BooleanWrapper that can be an output for a ConnectionClass: Connection – Passes update requests from an InputBoolean or a Neuron to another Neuron. Cannot be constructed directly; instead, connections are made using the connect() static method. Connections can be inhibitive (they are excitatory by default) and this property is defined when the connection is made. Class: Network – Abstract class that can be subclassed to encapsulate a structure of Neurons to protect the internal structure.  A network interfaces with Neurons and Booleans in client code through its input and output BufferNeurons.Package: logic – Implementations of basic logic functions using the library. The class names should be self-explanatory: ANDNeuron, ORNeuron, XORNetwork.Package: apps – Applications of the libraryClass: Examples– Contains very basic examples of use of the library that demonstrate its functionality. Class: OneBitAdder – A network that adds the two bits received as input and provides the two output bits resulting from the addition of the inputs. Overview of Internal Functioning	The Neuron class is the central unit of the library. Internally, the Neuron is an Observer, so the update method is called when an upstream source of Boolean information is updated.  If the update is true or false the Neuron increments or decrements its internal numerical value appropriately. On each update, the Neuron checks if its Boolean value changed, and if it did then it alerts downstream Neurons because it is also an Observable class.       Communication with other Neurons is facilitated using Java’s built-in observation capabilities.  Because there are two types of connection (inhibitive and excitatory) Neurons cannot simply observe each other for updates.  Instead, a Connection is established that defines whether or not it is inhibitive. The Connection class receives update requests from upstream and forwards them downstream.  When the update command goes out, the Connection sends a reference to itself to the object on the end of the connection.  The Neuron or Boolean at the end then inspects the Connection to see if it is inhibitive or excitatory and acts appropriately. Issues and Shortcomings 	There are a handful of shortcomings and caveats to take into account that result from the design of the library.  First, it is important to realize the individual Neurons don’t have a set number of inputs determined at the time of construction. Instead, client code can connect as many inputs as it would like.  This is not an entirely missing feature because a developer can wrap a Neuron in a Network in order to only expose a limited number of inputs to external components. However, it is still a security issue that Neurons can be connected to an unlimited number of inputs.       There is a similar limitation and security risk in the assumption that all inputs to a Neuron begin with the value false. A Neuron is only asked to update when a change occurs upstream, and it assumes that all its inputs are false when it is first set up (InputBooleans are false by default).  However, client code could easily set an InputBoolean to true before connecting it to a Neuron. If such a boolean is flipped again then the Neuron would have a negative value, which is an undefined state for a Neuron.  Given sufficient time the software could be updated to alleviate these shortcomings but it would not involve completely trivial changes.  Extensions and Applications	This type of software along with potential extensions has applications beyond the obvious use for demonstrating McCulloch-Pitts neurons to undergraduates. One such extension is providing a user interface to arrange and connect Neurons visually. Networks are essentially graphs, and as origin of the word suggests, graphs are best understood visually. The most natural way to complete homework assignments involving McCulloch-Pitts Neurons was to draw the connections out, so it is clearly the most intuitive way of dealing with this model. 	With such a GUI a number of visualization applications would be possible. For example, the software could be used to visualize logic statements and might be useful in the teaching of first order logic and digital logic. Laying out Neurons would essentially be a visual logical programming language that would be based on simple math and therefore simple to reason about. Additionally, a graphical component might be useful as a type of mind-mapping tool for laying out a decision process visually. 	A simpler extension to make the library easier to use would be to develop an interpreter for a simple plain-text method of laying out Neurons.  This extension would help alleviate issues with client code being able to cause undefined behavior since clients using an external plain-text markup would not be in danger of setting up networks incorrectly. Example OutputExamples.java:Majority neuron output with 2/3 inputs active: trueMajority neuron output with 1/3 inputs active: falseMajority neuron output with 2/3 inputs active and inhibition inactive: trueMajority neuron output with 2/3 inputs active and inhibition active: falseMajority neuron output with 1/3 inputs active and inhibition active: falseBufferNeuron with false input: falseBufferNeuron with true input: trueOneBitAdder.java:Testing 1 bit adder: 0 + 0 = false false1 + 0 = false true0 + 1 = false true1 + 1 = true falseXORNetwork.java: XORNetwork output with 0/2 inputs on: falseXORNetwork output with 1/2 inputs on: trueXORNetwork output with 1/2 inputs (other input) on: trueXORNetwork output with 2/2 inputs on: false